### 什么是GC

    垃圾回收，指对不再使用的内存分配空间的回收
    由赋值器和回收器组成
    
### 根对象是什么

    全局变量：程序在编译期就能确定的那些存在于程序整个生命周期的变量。
    执行栈：每个 goroutine 都包含自己的执行栈，这些执行栈上包含栈上的变量及指向分配的堆内存区块的指针。
    寄存器：寄存器的值可能表示一个指针，参与计算的这些指针可能指向某些赋值器分配的堆内存区块。
    
### Gc的实现方式

    1.从方法上有追踪和引用计数，分代搜集几种
    2.追踪：从根对象出发，推导扫描每个对象的引用，然后回收可回收是数量。
    3.引用计数：每个对象自己维护被引用的计数器，计数器归零则可回收
    
### 分代式

    分代式只指，存活时间较久的，认为可能存活更久，存活时间较短的，则可能存活的时间较短
    所以区分了永久代，老年代和年轻代
    
### go采用三色标记法

    go采用的是，无分代，不整理，并发的三色标记法
    白色：可能存活。灰色：波面。黑色：确定存活
    初始所有对象为白色，由根对象出发，推导各个节点，最终不可达的白色节点为死亡节点，需要回收
    
    传统标记清除法需要在整个gc周期内stw，而三色标记清除法，可以缩短至标记完成阶段，然后异步清除
    后期版本的go还引入了混合写屏障更叫减少了标记清除的范围
    
### 三色不变式
    强三色不变式 白色对象不能新增到黑色对象上
    弱三色不变式，所有黑色对象引用的对象都是处于灰色保护状态
    
### 插入屏障
    新增对象时，标记为灰色
    因为栈会频繁入栈出栈，不适用在栈中，只应用在堆上（强三色）
    
### 删除屏障
    删除对象，如果对象是白色，标记为灰色
    弱三色不变式（真正删除的对象下一个gc才会被清理）

### 混合写屏障

    1、GC开始将栈上的对象全部扫描并标记为黑色(之后不再进行第二次重复扫描，无需STW)，
    2、GC期间，任何在栈上创建的新对象，均为黑色。
    3、被删除的对象标记为灰色。
    4、被添加的对象标记为灰色。

满足: 变形的弱三色不变式.
    
  
### STW

    stop the world 和start the world 的缩写
    STW 在垃圾回收过程中为了保证实现的正确性、防止无止境的内存增长等问题而不可避免的需要停止赋值器进一步操作对象图的一段过程。
    
### 何时出发gc

     主动调用runtime.GC，系统监控2min没有执行gc了，通过步调算法，监控内存增长，增长到一定程度后，启动gc
     
### gc调优

    如何gc带来的开销主要是stw，那么gc的调优主要是减少内存的申请，提高已申请内存的复用率，控制分配内存的速度
