### 缓存策略 [参考](https://zhuanlan.zhihu.com/p/86396877)

    目前主流的缓存中间件是redis，采坑成本非常低，易于上手，稳定性高

#### Cache-Aside

    这可能是最常用的缓存方法。缓存位于一边，应用程序直接与缓存和数据库对话。
    - 流程
    1.应用程序首先检查缓存。
    2.如果在缓存中找到，表示已经命中缓存。数据被读取并返回给应用程序。
    3.如果在缓存中没有找到，则未命中缓存。应用程序必须做一些额外的工作，它需要查询数据库来读取数据，将数据返回给客户端，然后还要将数据存储在缓存中，这样对相同数据的后续读取可以命中缓存。
    
    - 注意
        缓存穿透时，在分布式或者高并发场景下，很容易引起访问高峰，造成db不可用
    可以在穿透时加互斥锁解决
  
    - 适合场景
        一般适合读多的场景
    
#### Read-though

    Read-though策略下的缓存与数据库保持一致。当缓存丢失时，它从数据库加载相应的数据。
    
    虽然read-through和cache-aside非常相似，但至少有两个关键区别:
    a.在cache-aside中，应用程序负责从数据库中获取数据并填充缓存。在read-through中，此逻辑通常由库或独立缓存提供程序支持。
    b.与cache-aside不同，read-through cache中的数据模型不能与数据库中的数据模型不同。
    
#### Write-Through Cache

    在这种写策略中，首先将数据写入缓存，然后写入数据库。缓存与数据库保持一致，写操作总是通过缓存到达主数据库。
    
#### Write-Around

    这种策略下，数据直接写入数据库，只有读取的数据才能进入缓存
    
#### Write-Behind

    这种策略下，应用程序将数据写入缓存，缓存会立即确认，并在延迟一段时间后将数据写入数据库
    
    
### 对缓存过去策略

#### 先写db再删缓存

    写-->读-->删除 =>中间仍会读到脏数据，
    删除--> 首次读 无命中缓存，高并发会引起大量穿透
    
    t1 :读缓存->穿透数据库 ->                       ->写缓存
    t2                    修改数据库 -> 删除缓存
    如果t1写缓存卡顿会造成脏数据，但是概率不高
    
#### 先删缓存后写db

    删除 -> 读 -> 写db， 中会读到脏数据
    同样会有缓存穿透的问题
    
#### 先更新数据库，再更新缓存

    同t1t2有覆盖的可能

#### read/write through 缓存代理

#### Write-Behind
     